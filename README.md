## Hexagonal Architecture with CQRS Pattern Sample

### 🚀 배경 

- Nettee 백엔드 팀의 프로젝트 방향성을 결정하기 위해 샘플 코드를 작성 [ Reviewer : [merge-simpson](https://github.com/merge-simpson) ]
- 헥사고날 아키텍처의 의미 수준과 구현 수준에 고찰과 리서치 내용 전달


### 📖 목차

1. [폴더 구조](#1️⃣-폴더-구조)  
2. [Hexagonal Architecture에 대해](#2️⃣--hexagonal-architecture에-대해)  
3. [추가적인 리서치 설명](#3️⃣-추가적인-리서치-설명)  

### 1️⃣ 폴더 구조 

- SRC 폴더 구조

```
  └─com
      └─nettee
          ├─board
          │  ├─adapter              --  외부와의 상호작용을 처리하는 계층, application 입출력을 담당
          │  │  ├─in                  --  외부로부터의 입력을 처리하는 어댑터
          │  │  │  ├─mapper             --  DTO <-> Domain 매핑 클래스
          │  │  │  └─web                -- Web 요청을 처리하는 컨트롤러 및 DTO 정의
          │  │  │      └─dto
          │  │  └─out                 --  외부로부터의 출력을 처리하는 어댑터 ( DB, Event, Message 처리 ) 
          │  │      ├─mapper            --  Entity <-> Domain 매핑 클래스
          │  │      └─persistence       -- 영속성 계층의 구현체 (예: JPA, MyBatis 등)
          │  │          └─entity
          │  └─application            -- 핵심 비즈니스 로직이 포함된 계층, 도메인과 유스케이스를 정의
          │      ├─domain               -- 비즈니스 도메인 정의
          │      ├─port                 -- adpater와 상호작용을 위한 인터페이스 정의
          │      ├─service              -- 비즈니스 로직을 처리하는 서비스 클래스
          │      └─usecase              -- 특정 유스케이스(기능) 인터페이스 정의
          └─common
```

---

### 2️⃣  Hexagonal Architecture에 대해



---

### 3️⃣ 추가적인 리서치 설명


#### 🧐잠깐만 아키텍처가 뭔데?

'**Architecture**' 의 영단어 뜻은 ’건축학‘ 이라는 뜻을 가지며, 대한민국에서는 건축학을 그냥 건축학이라 부르지 영어로 잘 사용하지는 않습니다. 

그에 반해, 아키텍처란 말은 IT 분야에 자주 쓰이는 용어이며, 사전적 정의로 나무위키에 따르면 다음과 같습니다.

```
목표 대상의 구성과 동작 원리, 구성 요소 간의 관계 및 시스템 외부 환경과의 관계를 설명하는 설계도 - 출처 namuwiki
```

단순히 `목적성을 가진 설계`라고 생각하면 좋을 것 같습니다. IT에서는 `시스템`이란 단어가 너무 추상적이기에 보다 구체적인 `인간의 몸`을 생각해보죠.

인간이 걷고자 한다면 인간의 몸은 다리, 뼈, 근육, 신경 등의 구성 요소가 서로 유기적으로 연결되어야 걸을 수 있습니다. 신경과   

#### CQRS 패턴에 대해

- ⚖️ CQRS (Command and Query Responsibility Segregation)

CQRS는 Command와 Query(명령과 조회)의 책임을 분리하는 아키텍처 패턴입니다. 이 패턴은 읽기 작업과 쓰기 작업을 분리하여 **시스템의 성능, 확장성, 보안성**을 극대화합니다. 또한, 시스템 유연성을 높여 복잡한 업데이트 요청에서도 충돌 방지를 지원합니다.

- ❓왜 사용하게 됐을까?

전통적인 CRUD 기반 아키텍처는 DB에서 데이터 조회, 업데이트 하는데 같은 데이터 모델이 사용되었습니다. 간단한 CRUD 작업에 대해서라면 효과적이지만, 복잡한 어플리케이션에서는 이러한 접근 방식은 **유지 보수를 어렵게 만들 수 있습니다.** 

  - **읽기와 쓰기 작업에서 사용되는 데이터 표현들이 서로 일치 않는 경우, 일부 작업에서는 필요하지 않는 추가적이 컬럼이나 속성의 업데이트가 이뤄져야 합니다**
    
  - **동일한 데이터 세트에 대해 병렬로 작업이 수행될 때 데이터 경합이 발생할 수 있습니다.**
    
  - **정보 조회를 위해 요구되는 복잡한 쿼리로 인해 성능에 부정적인 영향을 줄 수 있습니다.**
  
  - **하나의 데이터 모델이 읽기와 쓰기를 모두 수행 시, 보안 관리가 복잡합니다.**

`CQRS`는 읽기와 쓰기를 각각 다른 모델로 분리한다. `명령(Command)`을 통해 데이터를 쓰고, `쿼리(Query)`를 통해 데이터를 읽는다.

    `Command(명령)`은 **수행할 작업 중심**이 되어야 한다. ex) '호텔 룸 예약', '호텔 룸 취소'
     또한 비동기적으로 큐에 쌓인 후 수행된다.

    `쿼리(Query)`는 데이터 베이스를 결코 수정하지 않으며, 어떠한 도메인 로직도 캡슐화하지 않은 DTO만을 반환한다.

`읽기/쓰기` 모델들을 서로 격리시키며 **어플리케이션 디자인과 구현을 더욱 간단한게 만들어준다.**
하지만 CQRS 코드는 ORM 툴을 통해 DB 스키마로부터 자동으로 생성되도록 할 수 없다는 단점이 있다. 

`읽기 DB`의 경우, 복잡한 조인문이나 ORM 매핑을 방지하기 위해 조회에 최적화된 별도의 DB 스키마를 가질 수 있다.

    - materialized view
        - 일반 뷰와는 달리 쿼리의 결과를 실제 테이블 형태로 물리적으로 저장하는 것, 쿼리의 결과를 DB 테이블 형태로 저장해 두고, 필요할 때마다 저장된 데이터를 빠르게 조회할 수 있도록 함. (REFRESH 명령문을 통해 주기적인 갱신이 필요함)

즉, 단지 다른 DB 스키마가 아니라 아예 다른 타입의 데이터 저장소를 사용할 수도 있다. 예를 들면 쓰기는 RDBMS를 사용하고, 읽기의 경우 몽고DB와 같은 NoSql을 사용하는 것이다.

별도의 읽기/쓰기 데이터 저장소가 사용된다면, 반드시 동기화가 이뤄져야 한다. 보통 이는 쓰기 모델이 DB에 수정사항이 발생할 때마다 이벤트를 발행함으로써 이뤄진다.
**이때 DB 업데이트와 이벤트 발행은 반드시 하나의 트랜잭션 안에서 이뤄져야한다.**

`CQRS`의 장점은 다음과 같다.
    
    - 읽기와 쓰기 각각에 대해 독립적으로 스케일링을 하는 것을 가능하게 해준다. (Lock 경합이 최소화가 된다.)
      Lock 경합은 데이터 수정인 상태에서 읽기 작업이 온다면 대기상태에 놓인다. 분리함으로써 더욱 최소화가 가능하다.

    - 읽기와 쓰기를 분리함으로 보안 관리가 용이해진다.
    - 읽기와 쓰기에 대한 관심사 분리로 시스템의 유지 보수가 더욱 쉬워 진다.
    - Materialized view를 통해 복잡한 조인문을 사용하지 않을 수 있다.


`CQRS`의 단점은 다음과 같다.

    - 읽기/쓰기 저장소가 분리된다면, 읽기 데이터가 최신이 데이터가 아닐 수도 있다. 읽기 저장소에는 쓰기 저장소의 변경 사항들이 반영되어야 하는데, 이에는 딜레이가 생긴다.
    
`CQRS의 이벤트 소싱`
이벤트소싱이란 모든 명령(Command)을 이벤트 형태로 별도의 이벤트 저장소에 저장한다. 이 명령들은 자연스럽게 다시 사용할 수 있습니다. 강한 일관성 및 실시간 업데이트가 필요한 시스템에는 적합하지 않을 수 있습니다.

---
